require 'ldusk'
require 'lduster'
require 'vector'

-- make a list of all available pawns on this team
local function ai_scan_pawns(team_id: cint): vector(cshort)
    local my_pawns: vector(cshort) = {}

    -- scan all pawns
    for pawn_ix = 0, TEAM_MAX_PAWNS - 1 do
        local pawn_gid = LPAWN_GID(team_id, pawn_ix)
        local pawn: *Pawn = game_get_pawn_by_gid(pawn_gid)

        if pawn.alive then
            my_pawns:push(pawn_gid)
        end
    end

    return my_pawns
end

local function ai_can_pawn_move_to(pawn_gid: cshort, pos: VPos16): boolean
    local tile_check = false
    -- check tile, empty and walkable
    if (board_util_is_on_board(pos.x, pos.y) > 0 and board_util_is_walkable(pos.x, pos.y) > 0 and board_get_pawn(LBOARD_POS(pos.x, pos.y)) == nilptr) then
        tile_check = true
    end

    local range_check = false
    -- check range
    -- calculate range buffer and check
    -- for now, skip it
    range_check = true

    return range_check and tile_check
end

-- plan moves for a particular team
global function ai_plan_moves(team_id: cint, move_buf: *QueuedMove, move_buf_len: cint): cint
    local blackboard: *[0]cuchar = &game_ai_blackboard

    -- use blackboard slot as counter
    local bb_base = team_id * 1024
    blackboard[bb_base + 0] = blackboard[bb_base + 0] + 1

    local moves: *[0]QueuedMove = move_buf
    local move_ix = 0

    local my_pawns = ai_scan_pawns(team_id)

    -- move everyone forward
    for i = 0, my_pawns.size - 1 do
        local pawn_gid = my_pawns[i]
        local pawn: *Pawn = game_get_pawn_by_gid(pawn_gid)
        local curr_tile = board_find_pawn_tile(pawn_gid)
        local curr_tile_pos = board_util_tid_to_pos(curr_tile)

        local dest_pos = curr_tile_pos

        -- alternate march y direction using counter
        if (blackboard[bb_base + 0] % 2 == 0) then
            dest_pos.y = dest_pos.y + 1
        else
            dest_pos.y = dest_pos.y - 1
        end

        -- check if we can move there
        if not ai_can_pawn_move_to(pawn_gid, dest_pos) then
            -- can't move there
            continue
        end

        -- add a move for this pawn
        moves[move_ix] = {type = QUEUEDMOVE_MOVE, pawn0 = pawn_gid, start_pos = curr_tile_pos, end_pos = dest_pos}

        -- increment move index
        move_ix = move_ix + 1
    end

    -- clean up
    my_pawns:destroy()

    -- return how many moves were planned
    return move_ix
end