require 'ldusk'
require 'lduster'
require 'vector'
require 'hashmap'
require 'allocators.general'

local range_data_max_size <comptime> = 128
local Relocs = @record{
    map: hashmap(VPos16, cshort)
}
local PawnMoveCache = @record{
    relocs: *Relocs,
    range_data: *[range_data_max_size]VPos16,
    range_data_count: cint
}

-- make a list of all available pawns on this team
local function ai_scan_pawns(team_id: cint): vector(cshort)
    local my_pawns: vector(cshort) = {}

    -- scan through all pawn slots
    -- add all that are alive to a list
    for pawn_ix = 0, TEAM_MAX_PAWNS - 1 do
        local pawn_gid = LPAWN_GID(team_id, pawn_ix)
        local pawn: *Pawn = game_get_pawn_by_gid(pawn_gid)

        if pawn.alive > 0 then
            my_pawns:push(pawn_gid)
        end
    end

    return my_pawns
end

local function ai_get_range_data(pos: VPos16, move: cint)
    local range_data: *[range_data_max_size]VPos16 = default_allocator:new(@[range_data_max_size]VPos16)
    local range_data_count = board_util_calc_rangebuf(pos.x, pos.y, move, range_data, range_data_max_size)

    return range_data, range_data_count
end

local function ai_destroy_range_data(range_data: *[range_data_max_size]VPos16)
    default_allocator:delete(range_data)
end

local function ai_can_pawn_move_to(pawn_gid: cshort, from_pos: VPos16, pos: VPos16, move_cache: PawnMoveCache): boolean
    local tile_check = false
    -- check tile, empty and walkable
    if (board_util_is_on_board(pos.x, pos.y) > 0 and board_util_is_walkable(pos.x, pos.y) > 0) then
        -- valid tile, check if occupied
        local is_occupied_before = board_get_pawn(LBOARD_POS(pos.x, pos.y)) ~= nilptr
        local is_reloc = move_cache.relocs.map:peek(pos) ~= nilptr

        -- double check using relocs to see if pawn is already planned to move there
        if is_reloc then
            local reloc_pawn_gid: cshort = move_cache.relocs.map[pos]
            mgba_printf(1, "pawn %d is already planned to move to %d,%d", reloc_pawn_gid, pos.x, pos.y)
            if ((not is_occupied_before) and reloc_pawn_gid >= 0) then
                -- someone else is already there
                tile_check = false
            end
            if is_occupied_before and reloc_pawn_gid < 0 then
                -- actually it is no longer occupied
                tile_check = true
            end
        elseif not is_occupied_before then
            -- no reloc, so it is free
            tile_check = true
        end

        -- tile_check = not is_occupied_before
    end

    local range_check = false
    -- check range    
    for i = 0, move_cache.range_data_count - 1 do
        local range_pos = ($move_cache.range_data)[i]
        if (range_pos.x == pos.x and range_pos.y == pos.y) then
            range_check = true
            break
        end
    end

    return range_check and tile_check
end

-- get the closest tile in range to the destination
local function ai_get_closest_tile_in_range(pawn_gid: cshort, from_pos: VPos16, to_pos: VPos16, move_cache: PawnMoveCache): VPos16
    local class_data = pawn_get_classdata(pawn_gid)

    -- find the closest tile in range
    local closest_tile = from_pos
    local closest_dist = 999999
    for i = 0, move_cache.range_data_count - 1 do
        local range_pos = ($move_cache.range_data)[i]
        local dist = board_dist(range_pos.x, range_pos.y, to_pos.x, to_pos.y)

        -- ensure that we are able to move there
        if not ai_can_pawn_move_to(pawn_gid, from_pos, range_pos, move_cache) then
            continue
        end

        if dist < closest_dist then
            closest_tile = range_pos
            closest_dist = dist
        end
    end

    return closest_tile
end

-- plan moves for a particular team
global function ai_plan_moves(team_id: cint, move_buf: *QueuedMove, move_buf_len: cint): cint
    local blackboard: *[0]cuchar = &game_ai_blackboard

    -- pick blackboard base slot based on team id
    local bb_base = team_id * 1024
    -- set first blackboard slot
    blackboard[bb_base + 0] = 0

    local moves: *[0]QueuedMove = move_buf
    local move_ix = 0

    -- list of all pawns on this team
    local my_pawns = ai_scan_pawns(team_id)
    -- list of all pawns on the enemy team
    local enemy_pawns = ai_scan_pawns((team_id + 1) % 2)

    -- map of locations and their future pawns
    local pawn_relocs: Relocs
    pawn_relocs.map = {}

    -- move everyone forward
    for i = 0, #my_pawns - 1 do
        local pawn_gid = my_pawns[i]
        local pawn: *Pawn = game_get_pawn_by_gid(pawn_gid)
        local curr_tile = board_find_pawn_tile(pawn_gid)
        local curr_tile_pos = board_util_tid_to_pos(curr_tile)

        local dest_pos = curr_tile_pos

        -- ensure there are enemy pawns available
        if #enemy_pawns <= 0 then
            break
        end
        
        local enemy_target_ix = blackboard[bb_base + 0]
        local enemy_target = enemy_pawns[enemy_target_ix]

        -- calc range data
        local class_data = pawn_get_classdata(pawn_gid)
        local range_data, range_data_count = ai_get_range_data(curr_tile_pos, class_data.move)
        local move_cache: PawnMoveCache = {
            relocs = &pawn_relocs,
            range_data = range_data,
            range_data_count = range_data_count
        }

        -- set range data to be cleaned up
        defer
            ai_destroy_range_data(range_data)
        end
        
        -- plan a move towards the enemy target
        local enemy_target_tile = board_find_pawn_tile(enemy_target)
        local enemy_target_tile_pos = board_util_tid_to_pos(enemy_target_tile)
        local pos_closer_to_enemy = ai_get_closest_tile_in_range(pawn_gid, curr_tile_pos, enemy_target_tile_pos, move_cache)
        dest_pos = pos_closer_to_enemy

        -- check if we can move there
        if not ai_can_pawn_move_to(pawn_gid, curr_tile_pos, dest_pos, move_cache) then
            -- can't move there
            continue
        end

        -- add a move for this pawn
        moves[move_ix] = {type = QUEUEDMOVE_MOVE, pawn0 = pawn_gid, start_pos = curr_tile_pos, end_pos = dest_pos}

        -- log that we are moving to this tile
        mgba_printf(1, "pawn %d is moving to %d,%d", pawn_gid, dest_pos.x, dest_pos.y)

        -- update relocs, setting previously occupied tile and new tile
        pawn_relocs.map[curr_tile_pos] = -1
        pawn_relocs.map[dest_pos] = pawn_gid

        -- increment move index
        move_ix = move_ix + 1
    end

    -- clean up
    my_pawns:destroy()
    enemy_pawns:destroy()
    pawn_relocs.map:destroy()

    -- return how many moves were planned
    return move_ix
end
